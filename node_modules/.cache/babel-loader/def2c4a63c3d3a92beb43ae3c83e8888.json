{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { PaymentService } from 'danielbonifacio-sdk';\nimport getThunkStatus from '../utils/getThunkStatus';\nconst initialState = {\n  fetching: false,\n  selected: [],\n  query: {\n    sort: ['scheduledTo', 'desc'],\n    page: 0,\n    size: 7\n  },\n  paginated: {\n    page: 0,\n    size: 7,\n    totalPages: 1,\n    totalElements: 0,\n    content: []\n  }\n};\nexport const getAllPayments = createAsyncThunk('payment/getAllPayments', async (_, {\n  getState,\n  dispatch,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      payment: {\n        query\n      }\n    } = getState();\n    const paymentPaginated = await PaymentService.getAllPayments(query);\n    await dispatch(storeList(paymentPaginated));\n  } catch (err) {\n    return rejectWithValue({ ...err\n    });\n  }\n});\nexport const approvePaymentsInBatch = createAsyncThunk('payment/approvePaymentsInBatch', async (paymentIds, {\n  dispatch\n}) => {\n  await PaymentService.approvePaymentsBatch(paymentIds);\n  await dispatch(getAllPayments());\n  await dispatch(storeSelectedKeys([]));\n});\nexport const deleteExistingPayment = createAsyncThunk('payment/deleteExistingPayment', async (paymentId, {\n  dispatch\n}) => {\n  await PaymentService.removeExistingPayment(paymentId);\n  await dispatch(getAllPayments());\n  await dispatch(storeSelectedKeys([]));\n});\nexport const setQuery = createAsyncThunk('payment/setQuery', async (query, {\n  dispatch\n}) => {\n  await dispatch(storeQuery(query));\n  await dispatch(getAllPayments());\n});\nconst PaymentSlice = createSlice({\n  initialState,\n  name: 'payment',\n  reducers: {\n    storeList(state, action) {\n      state.paginated = action.payload;\n    },\n\n    storeQuery(state, action) {\n      state.query = { ...state.query,\n        ...action.payload\n      };\n    },\n\n    storeSelectedKeys(state, action) {\n      state.selected = action.payload;\n    }\n\n  },\n\n  extraReducers(builder) {\n    const {\n      success,\n      error,\n      loading\n    } = getThunkStatus([getAllPayments, approvePaymentsInBatch, deleteExistingPayment]);\n    builder.addMatcher(success, state => {\n      state.fetching = false;\n    }).addMatcher(error, (state, action) => {\n      state.fetching = false;\n    }).addMatcher(loading, state => {\n      state.fetching = true;\n    });\n  }\n\n});\nexport const {\n  storeQuery,\n  storeList,\n  storeSelectedKeys\n} = PaymentSlice.actions;\nconst PaymentReducer = PaymentSlice.reducer;\nexport default PaymentReducer;","map":{"version":3,"sources":["D:/ReactProjetos/alganews-admin/src/core/store/Payment.slice.ts"],"names":["createAsyncThunk","createSlice","PaymentService","getThunkStatus","initialState","fetching","selected","query","sort","page","size","paginated","totalPages","totalElements","content","getAllPayments","_","getState","dispatch","rejectWithValue","payment","paymentPaginated","storeList","err","approvePaymentsInBatch","paymentIds","approvePaymentsBatch","storeSelectedKeys","deleteExistingPayment","paymentId","removeExistingPayment","setQuery","storeQuery","PaymentSlice","name","reducers","state","action","payload","extraReducers","builder","success","error","loading","addMatcher","actions","PaymentReducer","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { Key } from 'antd/lib/table/interface';\nimport { Payment, PaymentService } from 'danielbonifacio-sdk';\nimport { RootState } from '.';\nimport getThunkStatus from '../utils/getThunkStatus';\n\ninterface PaymentState {\n  paginated: Payment.Paginated;\n  fetching: boolean;\n  query: Payment.Query;\n  selected: Key[];\n}\n\nconst initialState: PaymentState = {\n  fetching: false,\n  selected: [],\n  query: {\n    sort: ['scheduledTo', 'desc'],\n    page: 0,\n    size: 7,\n  },\n  paginated: {\n    page: 0,\n    size: 7,\n    totalPages: 1,\n    totalElements: 0,\n    content: [],\n  },\n};\n\nexport const getAllPayments = createAsyncThunk(\n  'payment/getAllPayments',\n  async (_, { getState, dispatch, rejectWithValue }) => {\n    try {\n      const {\n        payment: { query },\n      } = getState() as RootState;\n      const paymentPaginated = await PaymentService.getAllPayments(query);\n      await dispatch(storeList(paymentPaginated));\n    } catch (err) {\n      return rejectWithValue({ ...err });\n    }\n  }\n);\n\nexport const approvePaymentsInBatch = createAsyncThunk(\n  'payment/approvePaymentsInBatch',\n  async (paymentIds: number[], { dispatch }) => {\n    await PaymentService.approvePaymentsBatch(paymentIds);\n    await dispatch(getAllPayments());\n    await dispatch(storeSelectedKeys([]));\n  }\n);\n\nexport const deleteExistingPayment = createAsyncThunk(\n  'payment/deleteExistingPayment',\n  async (paymentId: number, { dispatch }) => {\n    await PaymentService.removeExistingPayment(paymentId);\n    await dispatch(getAllPayments());\n    await dispatch(storeSelectedKeys([]));\n  }\n);\n\nexport const setQuery = createAsyncThunk(\n  'payment/setQuery',\n  async (query: Payment.Query, { dispatch }) => {\n    await dispatch(storeQuery(query));\n    await dispatch(getAllPayments());\n  }\n);\n\nconst PaymentSlice = createSlice({\n  initialState,\n  name: 'payment',\n  reducers: {\n    storeList(state, action: PayloadAction<Payment.Paginated>) {\n      state.paginated = action.payload;\n    },\n    storeQuery(state, action: PayloadAction<Payment.Query>) {\n      state.query = {\n        ...state.query,\n        ...action.payload,\n      };\n    },\n    storeSelectedKeys(state, action: PayloadAction<Key[]>) {\n      state.selected = action.payload;\n    },\n  },\n  extraReducers(builder) {\n    const { success, error, loading } = getThunkStatus([\n      getAllPayments,\n      approvePaymentsInBatch,\n      deleteExistingPayment,\n    ]);\n\n    builder\n      .addMatcher(success, (state) => {\n        state.fetching = false;\n      })\n      .addMatcher(error, (state, action) => {\n        state.fetching = false;\n      })\n      .addMatcher(loading, (state) => {\n        state.fetching = true;\n      });\n  },\n});\n\nexport const { storeQuery, storeList, storeSelectedKeys } =\n  PaymentSlice.actions;\n\nconst PaymentReducer = PaymentSlice.reducer;\nexport default PaymentReducer;\n"]},"metadata":{},"sourceType":"module"}