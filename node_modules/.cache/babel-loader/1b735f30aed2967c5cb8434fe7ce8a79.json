{"ast":null,"code":"import _regeneratorRuntime from\"D:/ReactProjetos/alganews-admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"D:/ReactProjetos/alganews-admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import axios from'axios';import Service from'danielbonifacio-sdk/dist/Service';import AuthService from'./Authorization.service';var REACT_APP_API_BASE_URL=process.env.REACT_APP_API_BASE_URL;if(REACT_APP_API_BASE_URL){Service.setBaseUrl(REACT_APP_API_BASE_URL);}Service.setRequestInterceptors(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(request){var accessToken;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:accessToken=AuthService.getAccessToken();// injeta o token de acesso na requisição\nif(accessToken){request.headers['Authorization']=\"Bearer \".concat(accessToken);}return _context.abrupt(\"return\",request);case 3:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}());Service.setResponseInterceptors(function(response){return response;},/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(error){var _error$response;var originalRequest,storage,codeVerifier,refreshToken,tokens;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:// recupera informações da requisição\noriginalRequest=error.config;// caso o erro seja de autenticação e ainda não foi feito o retry\nif(!((error===null||error===void 0?void 0:(_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===401&&!originalRequest._retry)){_context2.next=15;break;}originalRequest._retry=true;// recupera o code verifier e o refresh token\nstorage={codeVerifier:AuthService.getCodeVerifier(),refreshToken:AuthService.getRefreshToken()};codeVerifier=storage.codeVerifier,refreshToken=storage.refreshToken;// caso algum não exista, não é possível renovar o token\nif(!(!refreshToken||!codeVerifier)){_context2.next=8;break;}AuthService.imperativelySendToLogout();return _context2.abrupt(\"return\");case 8:_context2.next=10;return AuthService.getNewToken({codeVerifier:codeVerifier,refreshToken:refreshToken});case 10:tokens=_context2.sent;// armazena os tokens para novas requisições\nAuthService.setAccessToken(tokens.access_token);AuthService.setRefreshToken(tokens.refresh_token);// implementa o token na requisição\noriginalRequest.headers['Authorization']=\"Bearer \".concat(tokens.access_token);// retorna uma nova chamada do axios com essa requisição\nreturn _context2.abrupt(\"return\",axios(originalRequest));case 15:throw error;case 16:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref2.apply(this,arguments);};}());","map":{"version":3,"sources":["D:/ReactProjetos/alganews-admin/src/auth/httpConfig.ts"],"names":["axios","Service","AuthService","REACT_APP_API_BASE_URL","process","env","setBaseUrl","setRequestInterceptors","request","accessToken","getAccessToken","headers","setResponseInterceptors","response","error","originalRequest","config","status","_retry","storage","codeVerifier","getCodeVerifier","refreshToken","getRefreshToken","imperativelySendToLogout","getNewToken","tokens","setAccessToken","access_token","setRefreshToken","refresh_token"],"mappings":"ySAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAOC,CAAAA,OAAP,KAAoB,kCAApB,CACA,MAAOC,CAAAA,WAAP,KAAwB,yBAAxB,C,GAEQC,CAAAA,sB,CAA2BC,OAAO,CAACC,G,CAAnCF,sB,CAER,GAAIA,sBAAJ,CAA4B,CAC1BF,OAAO,CAACK,UAAR,CAAmBH,sBAAnB,EACD,CACDF,OAAO,CAACM,sBAAR,0FAA+B,iBAAOC,OAAP,kIACvBC,WADuB,CACTP,WAAW,CAACQ,cAAZ,EADS,CAG7B;AACA,GAAID,WAAJ,CAAiB,CACfD,OAAO,CAACG,OAAR,CAAgB,eAAhB,mBAA6CF,WAA7C,EACD,CAN4B,gCAQtBD,OARsB,wDAA/B,gEAWAP,OAAO,CAACW,uBAAR,CACE,SAACC,QAAD,QAAcA,CAAAA,QAAd,EADF,2FAEE,kBAAOC,KAAP,uMACE;AACMC,eAFR,CAE0BD,KAAK,CAACE,MAFhC,CAIE;AAJF,KAKM,CAAAF,KAAK,OAAL,EAAAA,KAAK,SAAL,yBAAAA,KAAK,CAAED,QAAP,0DAAiBI,MAAjB,IAA4B,GAA5B,EAAmC,CAACF,eAAe,CAACG,MAL1D,4BAMIH,eAAe,CAACG,MAAhB,CAAyB,IAAzB,CAEA;AACMC,OATV,CASoB,CACdC,YAAY,CAAElB,WAAW,CAACmB,eAAZ,EADA,CAEdC,YAAY,CAAEpB,WAAW,CAACqB,eAAZ,EAFA,CATpB,CAcYH,YAdZ,CAc2CD,OAd3C,CAcYC,YAdZ,CAc0BE,YAd1B,CAc2CH,OAd3C,CAc0BG,YAd1B,CAgBI;AAhBJ,KAiBQ,CAACA,YAAD,EAAiB,CAACF,YAjB1B,2BAkBMlB,WAAW,CAACsB,wBAAZ,GAlBN,iEAuByBtB,CAAAA,WAAW,CAACuB,WAAZ,CAAwB,CAC3CL,YAAY,CAAZA,YAD2C,CAE3CE,YAAY,CAAZA,YAF2C,CAAxB,CAvBzB,SAuBUI,MAvBV,gBA4BI;AACAxB,WAAW,CAACyB,cAAZ,CAA2BD,MAAM,CAACE,YAAlC,EACA1B,WAAW,CAAC2B,eAAZ,CAA4BH,MAAM,CAACI,aAAnC,EAEA;AACAf,eAAe,CAACJ,OAAhB,CACE,eADF,mBAEce,MAAM,CAACE,YAFrB,EAIA;AArCJ,iCAsCW5B,KAAK,CAACe,eAAD,CAtChB,eAyCQD,CAAAA,KAzCR,0DAFF","sourcesContent":["import axios from 'axios';\nimport Service from 'danielbonifacio-sdk/dist/Service';\nimport AuthService from './Authorization.service';\n\nconst { REACT_APP_API_BASE_URL } = process.env;\n\nif (REACT_APP_API_BASE_URL) {\n  Service.setBaseUrl(REACT_APP_API_BASE_URL);\n}\nService.setRequestInterceptors(async (request) => {\n  const accessToken = AuthService.getAccessToken();\n\n  // injeta o token de acesso na requisição\n  if (accessToken) {\n    request.headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\n\nService.setResponseInterceptors(\n  (response) => response,\n  async (error) => {\n    // recupera informações da requisição\n    const originalRequest = error.config;\n\n    // caso o erro seja de autenticação e ainda não foi feito o retry\n    if (error?.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      // recupera o code verifier e o refresh token\n      const storage = {\n        codeVerifier: AuthService.getCodeVerifier(),\n        refreshToken: AuthService.getRefreshToken(),\n      };\n\n      const { codeVerifier, refreshToken } = storage;\n\n      // caso algum não exista, não é possível renovar o token\n      if (!refreshToken || !codeVerifier) {\n        AuthService.imperativelySendToLogout();\n        return;\n      }\n\n      // renova o token\n      const tokens = await AuthService.getNewToken({\n        codeVerifier,\n        refreshToken,\n      });\n\n      // armazena os tokens para novas requisições\n      AuthService.setAccessToken(tokens.access_token);\n      AuthService.setRefreshToken(tokens.refresh_token);\n\n      // implementa o token na requisição\n      originalRequest.headers[\n        'Authorization'\n      ] = `Bearer ${tokens.access_token}`;\n\n      // retorna uma nova chamada do axios com essa requisição\n      return axios(originalRequest);\n    }\n\n    throw error;\n  }\n);"]},"metadata":{},"sourceType":"module"}