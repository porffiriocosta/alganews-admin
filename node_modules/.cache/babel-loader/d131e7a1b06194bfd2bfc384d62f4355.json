{"ast":null,"code":"import axios from 'axios';\nimport Service from 'danielbonifacio-sdk/dist/Service';\nimport AuthService from './Authorization.service';\nService.setRequestInterceptors(async request => {\n  const accessToken = AuthService.getAccessToken(); // injeta o token de acesso na requisição\n\n  if (accessToken) {\n    request.headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\nService.setResponseInterceptors(response => response, async error => {\n  var _error$response;\n\n  // recupera informações da requisição\n  const originalRequest = error.config; // caso o erro seja de autenticação e ainda não foi feito o retry\n\n  if ((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true; // recupera o code verifier e o refresh token\n\n    const storage = {\n      codeVerifier: AuthService.getCodeVerifier(),\n      refreshToken: AuthService.getRefreshToken()\n    };\n    const {\n      codeVerifier,\n      refreshToken\n    } = storage; // caso algum não exista, não é possível renovar o token\n\n    if (!refreshToken || !codeVerifier) {\n      window.alert('TODO: IMPLEMENTAR LOGOUT');\n      return;\n    } // renova o token\n\n\n    const tokens = await AuthService.getNewToken({\n      codeVerifier,\n      refreshToken\n    }); // armazena os tokens para novas requisições\n\n    AuthService.setAccessToken(tokens.access_token);\n    AuthService.setRefreshToken(tokens.refresh_token); // implementa o token na requisição\n\n    originalRequest.headers['Authorization'] = `Bearer ${tokens.access_token}`; // retorna uma nova chamada do axios com essa requisição\n\n    return axios(originalRequest);\n  }\n});","map":{"version":3,"sources":["D:/ReactProjetos/alganews-admin/src/auth/httpConfig.ts"],"names":["axios","Service","AuthService","setRequestInterceptors","request","accessToken","getAccessToken","headers","setResponseInterceptors","response","error","originalRequest","config","status","_retry","storage","codeVerifier","getCodeVerifier","refreshToken","getRefreshToken","window","alert","tokens","getNewToken","setAccessToken","access_token","setRefreshToken","refresh_token"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,OAAP,MAAoB,kCAApB;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AAEAD,OAAO,CAACE,sBAAR,CAA+B,MAAOC,OAAP,IAAmB;AAChD,QAAMC,WAAW,GAAGH,WAAW,CAACI,cAAZ,EAApB,CADgD,CAGhD;;AACA,MAAID,WAAJ,EAAiB;AACfD,IAAAA,OAAO,CAACG,OAAR,CAAgB,eAAhB,IAAoC,UAASF,WAAY,EAAzD;AACD;;AAED,SAAOD,OAAP;AACD,CATD;AAWAH,OAAO,CAACO,uBAAR,CACGC,QAAD,IAAcA,QADhB,EAEE,MAAOC,KAAP,IAAiB;AAAA;;AACf;AACA,QAAMC,eAAe,GAAGD,KAAK,CAACE,MAA9B,CAFe,CAIf;;AACA,MAAI,CAAAF,KAAK,SAAL,IAAAA,KAAK,WAAL,+BAAAA,KAAK,CAAED,QAAP,oEAAiBI,MAAjB,MAA4B,GAA5B,IAAmC,CAACF,eAAe,CAACG,MAAxD,EAAgE;AAC9DH,IAAAA,eAAe,CAACG,MAAhB,GAAyB,IAAzB,CAD8D,CAG9D;;AACA,UAAMC,OAAO,GAAG;AACdC,MAAAA,YAAY,EAAEd,WAAW,CAACe,eAAZ,EADA;AAEdC,MAAAA,YAAY,EAAEhB,WAAW,CAACiB,eAAZ;AAFA,KAAhB;AAKA,UAAM;AAAEH,MAAAA,YAAF;AAAgBE,MAAAA;AAAhB,QAAiCH,OAAvC,CAT8D,CAW9D;;AACA,QAAI,CAACG,YAAD,IAAiB,CAACF,YAAtB,EAAoC;AAClCI,MAAAA,MAAM,CAACC,KAAP,CAAa,0BAAb;AACA;AACD,KAf6D,CAiB9D;;;AACA,UAAMC,MAAM,GAAG,MAAMpB,WAAW,CAACqB,WAAZ,CAAwB;AAC3CP,MAAAA,YAD2C;AAE3CE,MAAAA;AAF2C,KAAxB,CAArB,CAlB8D,CAuB9D;;AACAhB,IAAAA,WAAW,CAACsB,cAAZ,CAA2BF,MAAM,CAACG,YAAlC;AACAvB,IAAAA,WAAW,CAACwB,eAAZ,CAA4BJ,MAAM,CAACK,aAAnC,EAzB8D,CA2B9D;;AACAhB,IAAAA,eAAe,CAACJ,OAAhB,CACE,eADF,IAEK,UAASe,MAAM,CAACG,YAAa,EAFlC,CA5B8D,CAgC9D;;AACA,WAAOzB,KAAK,CAACW,eAAD,CAAZ;AACD;AACF,CA1CH","sourcesContent":["import axios from 'axios';\nimport Service from 'danielbonifacio-sdk/dist/Service';\nimport AuthService from './Authorization.service';\n\nService.setRequestInterceptors(async (request) => {\n  const accessToken = AuthService.getAccessToken();\n\n  // injeta o token de acesso na requisição\n  if (accessToken) {\n    request.headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n\n  return request;\n});\n\nService.setResponseInterceptors(\n  (response) => response,\n  async (error) => {\n    // recupera informações da requisição\n    const originalRequest = error.config;\n\n    // caso o erro seja de autenticação e ainda não foi feito o retry\n    if (error?.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      // recupera o code verifier e o refresh token\n      const storage = {\n        codeVerifier: AuthService.getCodeVerifier(),\n        refreshToken: AuthService.getRefreshToken(),\n      };\n\n      const { codeVerifier, refreshToken } = storage;\n\n      // caso algum não exista, não é possível renovar o token\n      if (!refreshToken || !codeVerifier) {\n        window.alert('TODO: IMPLEMENTAR LOGOUT');\n        return;\n      }\n\n      // renova o token\n      const tokens = await AuthService.getNewToken({\n        codeVerifier,\n        refreshToken,\n      });\n\n      // armazena os tokens para novas requisições\n      AuthService.setAccessToken(tokens.access_token);\n      AuthService.setRefreshToken(tokens.refresh_token);\n\n      // implementa o token na requisição\n      originalRequest.headers[\n        'Authorization'\n      ] = `Bearer ${tokens.access_token}`;\n\n      // retorna uma nova chamada do axios com essa requisição\n      return axios(originalRequest);\n    }\n  }\n);\n"]},"metadata":{},"sourceType":"module"}